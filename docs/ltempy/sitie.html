<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ltempy.sitie API documentation</title>
<meta name="description" content="Contains utilities for reconstructing phase and magnetization from Lorentz images â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ltempy.sitie</code></h1>
</header>
<section id="section-intro">
<p>Contains utilities for reconstructing phase and magnetization from Lorentz images.</p>
<p>The most common use case is to generate a Lorentz object from a <code>.dm3</code> or <code>.ser</code> file.
Then you can analyze using high_pass(), sitie(), clip_data(), etc.</p>
<p>Example:</p>
<pre><code class="language-python">import ncempy.io.dm as dm
import ltempy as lp

fname = '/path/to/data.dm3'
dm3file = dm.dmReader(fname)

img = lp.lorentz(dm3file)
img.sitie(defocus=1e-3)
img.phase.clip_data(sigma=5).high_pass().low_pass()
img.Bx.clip_data(sigma=5).high_pass().low_pass()
img.By.clip_data(sigma=5).high_pass().low_pass()

### plot img.Bx, img.By, img.phase, img.data, img.rawData, etc
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ltempy is a set of LTEM analysis and simulation tools developed by WSP as a member of the McMorran Lab
# Copyright (C) 2021  William S. Parker
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;Contains utilities for reconstructing phase and magnetization from Lorentz images.

The most common use case is to generate a Lorentz object from a `.dm3` or `.ser` file.
Then you can analyze using high_pass(), sitie(), clip_data(), etc.

Example:

```python
import ncempy.io.dm as dm
import ltempy as lp

fname = &#39;/path/to/data.dm3&#39;
dm3file = dm.dmReader(fname)

img = lp.lorentz(dm3file)
img.sitie(defocus=1e-3)
img.phase.clip_data(sigma=5).high_pass().low_pass()
img.Bx.clip_data(sigma=5).high_pass().low_pass()
img.By.clip_data(sigma=5).high_pass().low_pass()

### plot img.Bx, img.By, img.phase, img.data, img.rawData, etc
```
&#34;&#34;&#34;

# %%
import numpy as np
import os

from . import process
from . import constants as _
from ._utils import damping
np.seterr(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;)

__all__ = [
                &#39;SITIEImage&#39;,
                &#39;sitie_image&#39;,
                &#39;ind_from_phase&#39;,
                &#39;ind_from_img&#39;,
                &#39;phase_from_img&#39;]

def sitie_image(datafile):
        &#34;&#34;&#34;Creates a `Lorentz` class instance for each image in a sequence.

        This function acts as a wrapper for the `Lorentz` class, adding an extra handler
        for image sequences. When the dictionary contains a sequence of images, it is split into
        individual `Lorentz` class instances.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts, or an array of 2d arrays of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes.
                For compatibility with `.dm3` files, the last 2 elements of the tuple are used. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units.
                For compatibility with `.dm3` files, the last 2 elements of the tuple are used. &lt;/li&gt;
                &lt;/ul&gt;

        **Returns**
        * **out** : _list, Lorentz_ &lt;br /&gt;
        A list of `wsp-tools.sitie.Lorentz` instances, if the dictionary is an image sequence.
        Otherwise, a single `wsp-tools.sitie.Lorentz` instance.
        &#34;&#34;&#34;
        if len(datafile[&#39;data&#39;].shape) == 2:
                return(SITIEImage(datafile))
        else:
                f1 = datafile.copy()
                out = []
                for dataset in datafile[&#39;data&#39;]:
                        f1[&#39;data&#39;] = dataset
                        f1[&#39;pixelSize&#39;] = [datafile[&#39;pixelSize&#39;][-2], datafile[&#39;pixelSize&#39;][-1]]
                        f1[&#39;pixelUnit&#39;] = [datafile[&#39;pixelUnit&#39;][-2], datafile[&#39;pixelUnit&#39;][-1]]
                        out.append(SITIEImage(f1))
                return(out)

class SITIEImage:
        &#34;&#34;&#34;A LorentzImage object represents an image containing only magnetic contrast.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units. &lt;br /&gt;
                Allowed values are `&#34;pm&#34;`, `&#34;nm&#34;`, `&#34;Âµm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, and `&#34;m&#34;`.&lt;/li&gt;
                &lt;/ul&gt;
        &#34;&#34;&#34;
        def __init__(self, datafile):
                self.data = process.ndap(datafile.get(&#39;data&#39;))
                self.dx = datafile.get(&#39;pixelSize&#39;)[0]
                self.dy = datafile.get(&#39;pixelSize&#39;)[1]
                self.x_unit = datafile.get(&#39;pixelUnit&#39;)[0]
                self.y_unit = datafile.get(&#39;pixelUnit&#39;)[1]
                self.x = np.arange(0,self.data.shape[1]) * self.dx
                self.y = np.arange(0,self.data.shape[0]) * self.dy
                self.phase = None
                self.Bx, self.By = None, None
                self.fix_units()

        def fix_units(self):
                &#34;&#34;&#34;Try to set the units to meters.&#34;&#34;&#34;
                if self.x_unit == &#39;m&#39;:
                        xr = 1
                elif self.x_unit == &#39;mm&#39;:
                        xr = 1e-3
                elif self.x_unit == &#39;Âµm&#39; or self.x_unit == &#39;um&#39;:
                        xr = 1e-6
                elif self.x_unit == &#39;nm&#39;:
                        xr = 1e-9
                elif self.x_unit == &#39;pm&#39;:
                        xr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                if self.y_unit == &#39;m&#39;:
                        yr = 1
                elif self.y_unit == &#39;mm&#39;:
                        yr = 1e-3
                elif self.y_unit == &#39;Âµm&#39; or self.y_unit == &#39;um&#39;:
                        yr = 1e-6
                elif self.y_unit == &#39;nm&#39;:
                        yr = 1e-9
                elif self.y_unit == &#39;pm&#39;:
                        yr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))

        def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
                &#34;&#34;&#34;Change the pixel units.

                **Parameters**

                * **xr** : _number, optional_ &lt;br /&gt;
                New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
                Default is `xr = 1`.

                * **x_unit** : _string, optional_ &lt;br /&gt;
                The new x-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). &lt;br /&gt;
                Default is `x_unit = &#34;&#34;`.

                * **yr** : _number, optional_ &lt;br /&gt;
                New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
                If left empty, defaults to `xr`&lt;br /&gt;
                Default is `yr = None`.

                * **y_unit** : _string, optional_ &lt;br /&gt;
                The new y-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
                Default is `y_unit = None`.

                **Returns**

                * **self** : _lorentz_
                &#34;&#34;&#34;
                if yr is None:
                        yr = xr
                if y_unit is None:
                        y_unit = x_unit
                self.x_unit = x_unit
                self.y_unit = y_unit
                self.dx *= xr
                self.dy *= yr
                self.x *= xr
                self.y *= yr
                return(self)

        def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
                &#34;&#34;&#34;Carries out phase and B-field reconstruction.

                Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

                **Parameters**

                * **df** : _number, optional_ &lt;br /&gt;
                The defocus at which the images were taken. &lt;br /&gt;
                Default is `df = 1e-3`.

                * **wavelength** : _number, optional_ &lt;br /&gt;
                The electron wavelength. &lt;br /&gt;
                Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

                **Returns**

                * **self** : _lorentz_
                &#34;&#34;&#34;
                self.phase = process.ndap(phase_from_img(self.data, df, self.dx, self.dy, wavelength))
                self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, thickness)]
                return(self)

        def validate(self, dx, threshold = 0.9, damping = damping, **kwargs):
                r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

                SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
                low divergence angle relative to the defocus and the spatial frequencies to be resolved).
                Another way to say this is that the damping envelope \(g(q_{\perp})\) of Ref (1), Eqn (4) is negligible.
                Therefore, this function checks for \(q_{\perp}\) such that \(e^{-g(q_{\perp})} &gt; t\) where \(t\) is
                a user-input threshold.

                **Parameters**

                * **dx** : _number_ &lt;br /&gt;
                The pixel size in meters. &lt;br /&gt;

                * **threshold** : _number, optional_ &lt;br /&gt;
                The minimum allowed value of \(e^{-g(q_{\perp})}\). Should be between 0 and 1. &lt;br /&gt;
                Default is `threshold = 0.9`.

                * **damping** : _function, optional_ &lt;br /&gt;
                The damping function \(g(q_{\perp})\). Defaults to Ref (1), Eqn (4). &lt;br /&gt;
                The default damping function takes the following kwargs:
                        &lt;ul&gt;
                                &lt;li&gt;
                                **defocus** : _number, optional_ &lt;br /&gt;
                                Default is `defocus = 1e-3`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **wavelength** : _number, optional_ &lt;br /&gt;
                                Default is `wavelength = 1.97e-12`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **C_s** : _number, optional_ &lt;br /&gt;
                                The spherical aberration coefficient. &lt;br /&gt;
                                Default is `C_s = 2.7e-3`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **divangle** : _number, optional_ &lt;br /&gt;
                                The divergence angle. &lt;br /&gt;
                                Default is `divangle = 1e-5`.
                                &lt;/li&gt;
                        &lt;/ul&gt;

                * ****kwargs** &lt;br /&gt;
                Any arguments to be passed to the damping function.
                &#34;&#34;&#34;
                QX = np.fft.fftfreq(len(self.x), dx)
                QY = np.fft.fftfreq(len(self.y), dx)
                qx, qy = np.meshgrid(QX, QY)
                test = np.exp(-damping(qx, qy, **kwargs))
                if not np.any(test &gt; threshold):
                        return(&#34;For these parameters, SITIE is valid only for features larger than your image size. &#34;)
                min_feature_size = 1 / np.max(np.sqrt(qx**2 + qy**2)[test &gt; threshold])
                return(&#34;For these parameters, SITIE is valid for feature sizes larger than {}m&#34;.format(min_feature_size))

def phase_from_img(img, defocus = 0, dx = 1, dy = 1, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the Aharonov-Bohm phase from a defocussed image.

        This is an implementation of the SITIE equation (Eq 10) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed Aharonov-Bohm phase shift.
        &#34;&#34;&#34;
        Sx = np.fft.fftfreq(img.shape[1], dx)
        Sy = np.fft.fftfreq(img.shape[0], dy)
        sx, sy = np.meshgrid(Sx, Sy)
        rhs = np.nan_to_num(2 * _.pi / wavelength / defocus * (1 - img / np.mean(img)), posinf = 0, neginf = 0)
        rhs = process.shift_pos(rhs)
        rhs = np.fft.fft2(rhs) / -4 / _.pi**2 / (sx**2 + sy**2)
        rhs = np.nan_to_num(rhs, posinf = 0, neginf = 0)
        phase = np.fft.ifft2(rhs)
        return(phase.real)

def ind_from_img(img, defocus = 0, dx = 1, dy = 1, thickness = 60e-9, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the magnetic induction from a defocussed image.

        This is an implementation of the SITIE equation Eq (10) and Eq (11) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed x-component of magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed y-component of magnetic induction.
        &#34;&#34;&#34;
        phase = phase_from_img(img, defocus, dx, dy, wavelength)
        Bx, By = ind_from_phase(phase, thickness)
        return(np.array([Bx.real, By.real]))

def ind_from_phase(phase, thickness = 60e-9):
        &#34;&#34;&#34;Calculate the magnetic induction given the Aharonov-Bohm phase shift.

        This is an implementation of Eq (11) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the electron phase immediately after the sample.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        The x-component of the magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        The y-component of the magnetic induction.
        &#34;&#34;&#34;
        dpdy, dpdx = np.gradient(phase)
        Bx = _.hbar/_.e/thickness * dpdy
        By = -_.hbar/_.e/thickness * dpdx
        return(np.array([Bx.real, By.real]))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ltempy.sitie.ind_from_img"><code class="name flex">
<span>def <span class="ident">ind_from_img</span></span>(<span>img, defocus=0, dx=1, dy=1, thickness=6e-08, wavelength=1.97e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct the magnetic induction from a defocussed image.</p>
<p>This is an implementation of the SITIE equation Eq (10) and Eq (11) from J. Chess et al., 2017, <em>Streamlined approach to mapping the magnetic induction of skyrmionic materials</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>img</strong> : <em>ndarray</em> <br />
The 2d image data.</p>
</li>
<li>
<p><strong>defocus</strong> : <em>number, optional</em> <br />
Default is <code>defocus = 0</code>.</p>
</li>
<li>
<p><strong>dx</strong> : <em>number, optional</em> <br />
The pixel spacing in the x-direction. <br />
Default is <code>dx = 1</code></p>
</li>
<li>
<p><strong>dy</strong> : <em>number, optional</em> <br />
The pixel spacing in the y-direction. <br />
Default is <code>dy = 1</code>.</p>
</li>
<li>
<p><strong>thickness</strong> : <em>number, optional</em> <br />
The thickness of the sample. <br />
Default is <code>thickness = 60e-9</code>.</p>
</li>
<li>
<p><strong>wavelength</strong> : <em>number, optional</em> <br />
The relativistic electron wavelength. <br />
Default is <code>wavelength = 1.97e-9</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li>
<p><strong>Bx</strong> : <em>ndarray</em> <br />
A 2d array containing the reconstructed x-component of magnetic induction.</p>
</li>
<li>
<p><strong>By</strong> : <em>ndarray</em> <br />
A 2d array containing the reconstructed y-component of magnetic induction.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind_from_img(img, defocus = 0, dx = 1, dy = 1, thickness = 60e-9, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the magnetic induction from a defocussed image.

        This is an implementation of the SITIE equation Eq (10) and Eq (11) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed x-component of magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed y-component of magnetic induction.
        &#34;&#34;&#34;
        phase = phase_from_img(img, defocus, dx, dy, wavelength)
        Bx, By = ind_from_phase(phase, thickness)
        return(np.array([Bx.real, By.real]))</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.ind_from_phase"><code class="name flex">
<span>def <span class="ident">ind_from_phase</span></span>(<span>phase, thickness=6e-08)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the magnetic induction given the Aharonov-Bohm phase shift.</p>
<p>This is an implementation of Eq (11) from J. Chess et al., 2017, <em>Streamlined approach to mapping the magnetic induction of skyrmionic materials</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>phase</strong> : <em>ndarray</em> <br />
A 2d array containing the electron phase immediately after the sample.</p>
</li>
<li>
<p><strong>thickness</strong> : <em>number, optional</em> <br />
The thickness of the sample. <br />
Default is <code>thickness = 60e-9</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li>
<p><strong>Bx</strong> : <em>ndarray</em> <br />
The x-component of the magnetic induction.</p>
</li>
<li>
<p><strong>By</strong> : <em>ndarray</em> <br />
The y-component of the magnetic induction.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind_from_phase(phase, thickness = 60e-9):
        &#34;&#34;&#34;Calculate the magnetic induction given the Aharonov-Bohm phase shift.

        This is an implementation of Eq (11) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the electron phase immediately after the sample.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        The x-component of the magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        The y-component of the magnetic induction.
        &#34;&#34;&#34;
        dpdy, dpdx = np.gradient(phase)
        Bx = _.hbar/_.e/thickness * dpdy
        By = -_.hbar/_.e/thickness * dpdx
        return(np.array([Bx.real, By.real]))</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.phase_from_img"><code class="name flex">
<span>def <span class="ident">phase_from_img</span></span>(<span>img, defocus=0, dx=1, dy=1, wavelength=1.97e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct the Aharonov-Bohm phase from a defocussed image.</p>
<p>This is an implementation of the SITIE equation (Eq 10) from J. Chess et al., 2017, <em>Streamlined approach to mapping the magnetic induction of skyrmionic materials</em>.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>img</strong> : <em>ndarray</em> <br />
The 2d image data.</p>
</li>
<li>
<p><strong>defocus</strong> : <em>number, optional</em> <br />
Default is <code>defocus = 0</code>.</p>
</li>
<li>
<p><strong>dx</strong> : <em>number, optional</em> <br />
The pixel spacing in the x-direction. <br />
Default is <code>dx = 1</code></p>
</li>
<li>
<p><strong>dy</strong> : <em>number, optional</em> <br />
The pixel spacing in the y-direction. <br />
Default is <code>dy = 1</code>.</p>
</li>
<li>
<p><strong>wavelength</strong> : <em>number, optional</em> <br />
The relativistic electron wavelength. <br />
Default is <code>wavelength = 1.97e-9</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><strong>phase</strong> : <em>ndarray</em> <br />
A 2d array containing the reconstructed Aharonov-Bohm phase shift.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phase_from_img(img, defocus = 0, dx = 1, dy = 1, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the Aharonov-Bohm phase from a defocussed image.

        This is an implementation of the SITIE equation (Eq 10) from J. Chess et al., 2017, _Streamlined approach to mapping the magnetic induction of skyrmionic materials_.

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed Aharonov-Bohm phase shift.
        &#34;&#34;&#34;
        Sx = np.fft.fftfreq(img.shape[1], dx)
        Sy = np.fft.fftfreq(img.shape[0], dy)
        sx, sy = np.meshgrid(Sx, Sy)
        rhs = np.nan_to_num(2 * _.pi / wavelength / defocus * (1 - img / np.mean(img)), posinf = 0, neginf = 0)
        rhs = process.shift_pos(rhs)
        rhs = np.fft.fft2(rhs) / -4 / _.pi**2 / (sx**2 + sy**2)
        rhs = np.nan_to_num(rhs, posinf = 0, neginf = 0)
        phase = np.fft.ifft2(rhs)
        return(phase.real)</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.sitie_image"><code class="name flex">
<span>def <span class="ident">sitie_image</span></span>(<span>datafile)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code>Lorentz</code> class instance for each image in a sequence.</p>
<p>This function acts as a wrapper for the <code>Lorentz</code> class, adding an extra handler
for image sequences. When the dictionary contains a sequence of images, it is split into
individual <code>Lorentz</code> class instances.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong>datafile</strong> : <em>dictionary</em> <br />
a dictionary with the following keys: <br />
<ul>
<li> <strong>data</strong> : <em>ndarray</em> <br />
A 2d array of the electron counts, or an array of 2d arrays of the electron counts. </li>
<li> <strong>pixelSize</strong> : <em>tuple</em> <br />
(<em>number</em>, <em>number</em>) - the x and y pixel sizes.
For compatibility with <code>.dm3</code> files, the last 2 elements of the tuple are used. </li>
<li> <strong>pixelUnit</strong> : <em>tuple</em> <br />
(<em>string</em>, <em>string</em>) - the x and y pixel units.
For compatibility with <code>.dm3</code> files, the last 2 elements of the tuple are used. </li>
</ul></li>
</ul>
<p><strong>Returns</strong>
* <strong>out</strong> : <em>list, Lorentz</em> <br />
A list of <code>wsp-tools.sitie.Lorentz</code> instances, if the dictionary is an image sequence.
Otherwise, a single <code>wsp-tools.sitie.Lorentz</code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sitie_image(datafile):
        &#34;&#34;&#34;Creates a `Lorentz` class instance for each image in a sequence.

        This function acts as a wrapper for the `Lorentz` class, adding an extra handler
        for image sequences. When the dictionary contains a sequence of images, it is split into
        individual `Lorentz` class instances.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts, or an array of 2d arrays of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes.
                For compatibility with `.dm3` files, the last 2 elements of the tuple are used. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units.
                For compatibility with `.dm3` files, the last 2 elements of the tuple are used. &lt;/li&gt;
                &lt;/ul&gt;

        **Returns**
        * **out** : _list, Lorentz_ &lt;br /&gt;
        A list of `wsp-tools.sitie.Lorentz` instances, if the dictionary is an image sequence.
        Otherwise, a single `wsp-tools.sitie.Lorentz` instance.
        &#34;&#34;&#34;
        if len(datafile[&#39;data&#39;].shape) == 2:
                return(SITIEImage(datafile))
        else:
                f1 = datafile.copy()
                out = []
                for dataset in datafile[&#39;data&#39;]:
                        f1[&#39;data&#39;] = dataset
                        f1[&#39;pixelSize&#39;] = [datafile[&#39;pixelSize&#39;][-2], datafile[&#39;pixelSize&#39;][-1]]
                        f1[&#39;pixelUnit&#39;] = [datafile[&#39;pixelUnit&#39;][-2], datafile[&#39;pixelUnit&#39;][-1]]
                        out.append(SITIEImage(f1))
                return(out)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ltempy.sitie.SITIEImage"><code class="flex name class">
<span>class <span class="ident">SITIEImage</span></span>
<span>(</span><span>datafile)</span>
</code></dt>
<dd>
<div class="desc"><p>A LorentzImage object represents an image containing only magnetic contrast.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong>datafile</strong> : <em>dictionary</em> <br />
a dictionary with the following keys: <br />
<ul>
<li> <strong>data</strong> : <em>ndarray</em> <br />
A 2d array of the electron counts. </li>
<li> <strong>pixelSize</strong> : <em>tuple</em> <br />
(<em>number</em>, <em>number</em>) - the x and y pixel sizes. </li>
<li> <strong>pixelUnit</strong> : <em>tuple</em> <br />
(<em>string</em>, <em>string</em>) - the x and y pixel units. <br />
Allowed values are <code>"pm"</code>, <code>"nm"</code>, <code>"Âµm"</code>, <code>"um"</code>, <code>"mm"</code>, and <code>"m"</code>.</li>
</ul></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SITIEImage:
        &#34;&#34;&#34;A LorentzImage object represents an image containing only magnetic contrast.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units. &lt;br /&gt;
                Allowed values are `&#34;pm&#34;`, `&#34;nm&#34;`, `&#34;Âµm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, and `&#34;m&#34;`.&lt;/li&gt;
                &lt;/ul&gt;
        &#34;&#34;&#34;
        def __init__(self, datafile):
                self.data = process.ndap(datafile.get(&#39;data&#39;))
                self.dx = datafile.get(&#39;pixelSize&#39;)[0]
                self.dy = datafile.get(&#39;pixelSize&#39;)[1]
                self.x_unit = datafile.get(&#39;pixelUnit&#39;)[0]
                self.y_unit = datafile.get(&#39;pixelUnit&#39;)[1]
                self.x = np.arange(0,self.data.shape[1]) * self.dx
                self.y = np.arange(0,self.data.shape[0]) * self.dy
                self.phase = None
                self.Bx, self.By = None, None
                self.fix_units()

        def fix_units(self):
                &#34;&#34;&#34;Try to set the units to meters.&#34;&#34;&#34;
                if self.x_unit == &#39;m&#39;:
                        xr = 1
                elif self.x_unit == &#39;mm&#39;:
                        xr = 1e-3
                elif self.x_unit == &#39;Âµm&#39; or self.x_unit == &#39;um&#39;:
                        xr = 1e-6
                elif self.x_unit == &#39;nm&#39;:
                        xr = 1e-9
                elif self.x_unit == &#39;pm&#39;:
                        xr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                if self.y_unit == &#39;m&#39;:
                        yr = 1
                elif self.y_unit == &#39;mm&#39;:
                        yr = 1e-3
                elif self.y_unit == &#39;Âµm&#39; or self.y_unit == &#39;um&#39;:
                        yr = 1e-6
                elif self.y_unit == &#39;nm&#39;:
                        yr = 1e-9
                elif self.y_unit == &#39;pm&#39;:
                        yr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))

        def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
                &#34;&#34;&#34;Change the pixel units.

                **Parameters**

                * **xr** : _number, optional_ &lt;br /&gt;
                New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
                Default is `xr = 1`.

                * **x_unit** : _string, optional_ &lt;br /&gt;
                The new x-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). &lt;br /&gt;
                Default is `x_unit = &#34;&#34;`.

                * **yr** : _number, optional_ &lt;br /&gt;
                New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
                If left empty, defaults to `xr`&lt;br /&gt;
                Default is `yr = None`.

                * **y_unit** : _string, optional_ &lt;br /&gt;
                The new y-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
                Default is `y_unit = None`.

                **Returns**

                * **self** : _lorentz_
                &#34;&#34;&#34;
                if yr is None:
                        yr = xr
                if y_unit is None:
                        y_unit = x_unit
                self.x_unit = x_unit
                self.y_unit = y_unit
                self.dx *= xr
                self.dy *= yr
                self.x *= xr
                self.y *= yr
                return(self)

        def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
                &#34;&#34;&#34;Carries out phase and B-field reconstruction.

                Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

                **Parameters**

                * **df** : _number, optional_ &lt;br /&gt;
                The defocus at which the images were taken. &lt;br /&gt;
                Default is `df = 1e-3`.

                * **wavelength** : _number, optional_ &lt;br /&gt;
                The electron wavelength. &lt;br /&gt;
                Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

                **Returns**

                * **self** : _lorentz_
                &#34;&#34;&#34;
                self.phase = process.ndap(phase_from_img(self.data, df, self.dx, self.dy, wavelength))
                self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, thickness)]
                return(self)

        def validate(self, dx, threshold = 0.9, damping = damping, **kwargs):
                r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

                SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
                low divergence angle relative to the defocus and the spatial frequencies to be resolved).
                Another way to say this is that the damping envelope \(g(q_{\perp})\) of Ref (1), Eqn (4) is negligible.
                Therefore, this function checks for \(q_{\perp}\) such that \(e^{-g(q_{\perp})} &gt; t\) where \(t\) is
                a user-input threshold.

                **Parameters**

                * **dx** : _number_ &lt;br /&gt;
                The pixel size in meters. &lt;br /&gt;

                * **threshold** : _number, optional_ &lt;br /&gt;
                The minimum allowed value of \(e^{-g(q_{\perp})}\). Should be between 0 and 1. &lt;br /&gt;
                Default is `threshold = 0.9`.

                * **damping** : _function, optional_ &lt;br /&gt;
                The damping function \(g(q_{\perp})\). Defaults to Ref (1), Eqn (4). &lt;br /&gt;
                The default damping function takes the following kwargs:
                        &lt;ul&gt;
                                &lt;li&gt;
                                **defocus** : _number, optional_ &lt;br /&gt;
                                Default is `defocus = 1e-3`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **wavelength** : _number, optional_ &lt;br /&gt;
                                Default is `wavelength = 1.97e-12`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **C_s** : _number, optional_ &lt;br /&gt;
                                The spherical aberration coefficient. &lt;br /&gt;
                                Default is `C_s = 2.7e-3`.
                                &lt;/li&gt;
                                &lt;li&gt;
                                **divangle** : _number, optional_ &lt;br /&gt;
                                The divergence angle. &lt;br /&gt;
                                Default is `divangle = 1e-5`.
                                &lt;/li&gt;
                        &lt;/ul&gt;

                * ****kwargs** &lt;br /&gt;
                Any arguments to be passed to the damping function.
                &#34;&#34;&#34;
                QX = np.fft.fftfreq(len(self.x), dx)
                QY = np.fft.fftfreq(len(self.y), dx)
                qx, qy = np.meshgrid(QX, QY)
                test = np.exp(-damping(qx, qy, **kwargs))
                if not np.any(test &gt; threshold):
                        return(&#34;For these parameters, SITIE is valid only for features larger than your image size. &#34;)
                min_feature_size = 1 / np.max(np.sqrt(qx**2 + qy**2)[test &gt; threshold])
                return(&#34;For these parameters, SITIE is valid for feature sizes larger than {}m&#34;.format(min_feature_size))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ltempy.sitie.SITIEImage.fix_units"><code class="name flex">
<span>def <span class="ident">fix_units</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to set the units to meters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_units(self):
        &#34;&#34;&#34;Try to set the units to meters.&#34;&#34;&#34;
        if self.x_unit == &#39;m&#39;:
                xr = 1
        elif self.x_unit == &#39;mm&#39;:
                xr = 1e-3
        elif self.x_unit == &#39;Âµm&#39; or self.x_unit == &#39;um&#39;:
                xr = 1e-6
        elif self.x_unit == &#39;nm&#39;:
                xr = 1e-9
        elif self.x_unit == &#39;pm&#39;:
                xr = 1e-12
        else:
                print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                return(self)
        if self.y_unit == &#39;m&#39;:
                yr = 1
        elif self.y_unit == &#39;mm&#39;:
                yr = 1e-3
        elif self.y_unit == &#39;Âµm&#39; or self.y_unit == &#39;um&#39;:
                yr = 1e-6
        elif self.y_unit == &#39;nm&#39;:
                yr = 1e-9
        elif self.y_unit == &#39;pm&#39;:
                yr = 1e-12
        else:
                print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                return(self)
        return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self, df=0.001, thickness=6e-08, wavelength=1.97e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out phase and B-field reconstruction.</p>
<p>Assigns <code>self.phase</code>, <code>self.Bx</code>, and <code>self.By</code> attributes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>df</strong> : <em>number, optional</em> <br />
The defocus at which the images were taken. <br />
Default is <code>df = 1e-3</code>.</p>
</li>
<li>
<p><strong>wavelength</strong> : <em>number, optional</em> <br />
The electron wavelength. <br />
Default is <code>wavelength = 1.96e-12</code> (relativistic wavelength of a 300kV electron).</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><strong>self</strong> : <em>lorentz</em></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
        &#34;&#34;&#34;Carries out phase and B-field reconstruction.

        Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

        **Parameters**

        * **df** : _number, optional_ &lt;br /&gt;
        The defocus at which the images were taken. &lt;br /&gt;
        Default is `df = 1e-3`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

        **Returns**

        * **self** : _lorentz_
        &#34;&#34;&#34;
        self.phase = process.ndap(phase_from_img(self.data, df, self.dx, self.dy, wavelength))
        self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, thickness)]
        return(self)</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.set_units"><code class="name flex">
<span>def <span class="ident">set_units</span></span>(<span>self, xr=1, x_unit='', yr=None, y_unit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the pixel units.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>xr</strong> : <em>number, optional</em> <br />
New x-units per old x-units. (For example, 1e3 to convert from meters to mm). <br />
Default is <code>xr = 1</code>.</p>
</li>
<li>
<p><strong>x_unit</strong> : <em>string, optional</em> <br />
The new x-units (e.g., "nm" or "Âµm"). <br />
Default is <code>x_unit = ""</code>.</p>
</li>
<li>
<p><strong>yr</strong> : <em>number, optional</em> <br />
New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
If left empty, defaults to <code>xr</code><br />
Default is <code>yr = None</code>.</p>
</li>
<li>
<p><strong>y_unit</strong> : <em>string, optional</em> <br />
The new y-units (e.g., "nm" or "Âµm"). If left empty, defaults to <code>x_unit</code>. <br />
Default is <code>y_unit = None</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><strong>self</strong> : <em>lorentz</em></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
        &#34;&#34;&#34;Change the pixel units.

        **Parameters**

        * **xr** : _number, optional_ &lt;br /&gt;
        New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
        Default is `xr = 1`.

        * **x_unit** : _string, optional_ &lt;br /&gt;
        The new x-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). &lt;br /&gt;
        Default is `x_unit = &#34;&#34;`.

        * **yr** : _number, optional_ &lt;br /&gt;
        New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
        If left empty, defaults to `xr`&lt;br /&gt;
        Default is `yr = None`.

        * **y_unit** : _string, optional_ &lt;br /&gt;
        The new y-units (e.g., &#34;nm&#34; or &#34;Âµm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
        Default is `y_unit = None`.

        **Returns**

        * **self** : _lorentz_
        &#34;&#34;&#34;
        if yr is None:
                yr = xr
        if y_unit is None:
                y_unit = x_unit
        self.x_unit = x_unit
        self.y_unit = y_unit
        self.dx *= xr
        self.dy *= yr
        self.x *= xr
        self.y *= yr
        return(self)</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, dx, threshold=0.9, damping=&lt;function damping&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the validity of the SITIE approximation for the given parameters.</p>
<p>SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
low divergence angle relative to the defocus and the spatial frequencies to be resolved).
Another way to say this is that the damping envelope <span><span class="MathJax_Preview">g(q_{\perp})</span><script type="math/tex">g(q_{\perp})</script></span> of Ref (1), Eqn (4) is negligible.
Therefore, this function checks for <span><span class="MathJax_Preview">q_{\perp}</span><script type="math/tex">q_{\perp}</script></span> such that <span><span class="MathJax_Preview">e^{-g(q_{\perp})} &gt; t</span><script type="math/tex">e^{-g(q_{\perp})} > t</script></span> where <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> is
a user-input threshold.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>dx</strong> : <em>number</em> <br />
The pixel size in meters. <br /></p>
</li>
<li>
<p><strong>threshold</strong> : <em>number, optional</em> <br />
The minimum allowed value of <span><span class="MathJax_Preview">e^{-g(q_{\perp})}</span><script type="math/tex">e^{-g(q_{\perp})}</script></span>. Should be between 0 and 1. <br />
Default is <code>threshold = 0.9</code>.</p>
</li>
<li>
<p><strong>damping</strong> : <em>function, optional</em> <br />
The damping function <span><span class="MathJax_Preview">g(q_{\perp})</span><script type="math/tex">g(q_{\perp})</script></span>. Defaults to Ref (1), Eqn (4). <br />
The default damping function takes the following kwargs:
<ul>
<li>
<strong>defocus</strong> : <em>number, optional</em> <br />
Default is <code>defocus = 1e-3</code>.
</li>
<li>
<strong>wavelength</strong> : <em>number, optional</em> <br />
Default is <code>wavelength = 1.97e-12</code>.
</li>
<li>
<strong>C_s</strong> : <em>number, optional</em> <br />
The spherical aberration coefficient. <br />
Default is <code>C_s = 2.7e-3</code>.
</li>
<li>
<strong>divangle</strong> : <em>number, optional</em> <br />
The divergence angle. <br />
Default is <code>divangle = 1e-5</code>.
</li>
</ul></p>
</li>
<li>
<p><strong>**kwargs</strong> <br />
Any arguments to be passed to the damping function.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, dx, threshold = 0.9, damping = damping, **kwargs):
        r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

        SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
        low divergence angle relative to the defocus and the spatial frequencies to be resolved).
        Another way to say this is that the damping envelope \(g(q_{\perp})\) of Ref (1), Eqn (4) is negligible.
        Therefore, this function checks for \(q_{\perp}\) such that \(e^{-g(q_{\perp})} &gt; t\) where \(t\) is
        a user-input threshold.

        **Parameters**

        * **dx** : _number_ &lt;br /&gt;
        The pixel size in meters. &lt;br /&gt;

        * **threshold** : _number, optional_ &lt;br /&gt;
        The minimum allowed value of \(e^{-g(q_{\perp})}\). Should be between 0 and 1. &lt;br /&gt;
        Default is `threshold = 0.9`.

        * **damping** : _function, optional_ &lt;br /&gt;
        The damping function \(g(q_{\perp})\). Defaults to Ref (1), Eqn (4). &lt;br /&gt;
        The default damping function takes the following kwargs:
                &lt;ul&gt;
                        &lt;li&gt;
                        **defocus** : _number, optional_ &lt;br /&gt;
                        Default is `defocus = 1e-3`.
                        &lt;/li&gt;
                        &lt;li&gt;
                        **wavelength** : _number, optional_ &lt;br /&gt;
                        Default is `wavelength = 1.97e-12`.
                        &lt;/li&gt;
                        &lt;li&gt;
                        **C_s** : _number, optional_ &lt;br /&gt;
                        The spherical aberration coefficient. &lt;br /&gt;
                        Default is `C_s = 2.7e-3`.
                        &lt;/li&gt;
                        &lt;li&gt;
                        **divangle** : _number, optional_ &lt;br /&gt;
                        The divergence angle. &lt;br /&gt;
                        Default is `divangle = 1e-5`.
                        &lt;/li&gt;
                &lt;/ul&gt;

        * ****kwargs** &lt;br /&gt;
        Any arguments to be passed to the damping function.
        &#34;&#34;&#34;
        QX = np.fft.fftfreq(len(self.x), dx)
        QY = np.fft.fftfreq(len(self.y), dx)
        qx, qy = np.meshgrid(QX, QY)
        test = np.exp(-damping(qx, qy, **kwargs))
        if not np.any(test &gt; threshold):
                return(&#34;For these parameters, SITIE is valid only for features larger than your image size. &#34;)
        min_feature_size = 1 / np.max(np.sqrt(qx**2 + qy**2)[test &gt; threshold])
        return(&#34;For these parameters, SITIE is valid for feature sizes larger than {}m&#34;.format(min_feature_size))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ltempy.sitie.ind_from_img" href="#ltempy.sitie.ind_from_img">ind_from_img</a></code></li>
<li><code><a title="ltempy.sitie.ind_from_phase" href="#ltempy.sitie.ind_from_phase">ind_from_phase</a></code></li>
<li><code><a title="ltempy.sitie.phase_from_img" href="#ltempy.sitie.phase_from_img">phase_from_img</a></code></li>
<li><code><a title="ltempy.sitie.sitie_image" href="#ltempy.sitie.sitie_image">sitie_image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ltempy.sitie.SITIEImage" href="#ltempy.sitie.SITIEImage">SITIEImage</a></code></h4>
<ul class="">
<li><code><a title="ltempy.sitie.SITIEImage.fix_units" href="#ltempy.sitie.SITIEImage.fix_units">fix_units</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.reconstruct" href="#ltempy.sitie.SITIEImage.reconstruct">reconstruct</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.set_units" href="#ltempy.sitie.SITIEImage.set_units">set_units</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.validate" href="#ltempy.sitie.SITIEImage.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>