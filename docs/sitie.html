<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ltempy.sitie API documentation</title>
<meta name="description" content="Contains utilities for reconstructing phase and magnetization from Lorentz images …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ltempy.sitie</code></h1>
</header>
<section id="section-intro">
<p>Contains utilities for reconstructing phase and magnetization from Lorentz images.</p>
<p>This module implements the Single Image Transport of Intensity Equation (SITIE) [1].</p>
<p>The most common use case is to generate a <code><a title="ltempy.sitie.SITIEImage" href="#ltempy.sitie.SITIEImage">SITIEImage</a></code> object from a <code>.dm3</code> or <code>.ser</code> file,
then reconstruct phase and induction with <code><a title="ltempy.sitie.sitie" href="#ltempy.sitie.sitie">sitie()</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python">import ncempy.io.dm as dm
import ltempy as lp

fname = '/path/to/data.dm3'
dm3file = dm.dmReader(fname)

img = lp.lorentz(dm3file)
img.reconstruct(defocus=1e-3)

### plot img.Bx, img.By, img.phase, img.data, etc
</code></pre>
<hr>
<ol>
<li>Chess, J. J. et al. Streamlined approach to mapping the magnetic induction of skyrmionic materials. Ultramicroscopy 177, 78–83 (2017).</li>
</ol>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ltempy is a set of LTEM analysis and simulation tools developed by WSP as a member of the McMorran Lab
# Copyright (C) 2021  William S. Parker
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.

&#34;&#34;&#34;Contains utilities for reconstructing phase and magnetization from Lorentz images.

This module implements the Single Image Transport of Intensity Equation (SITIE) [1].

The most common use case is to generate a `SITIEImage` object from a `.dm3` or `.ser` file,
then reconstruct phase and induction with `sitie()`.

Example:

```python
import ncempy.io.dm as dm
import ltempy as lp

fname = &#39;/path/to/data.dm3&#39;
dm3file = dm.dmReader(fname)

img = lp.lorentz(dm3file)
img.reconstruct(defocus=1e-3)

### plot img.Bx, img.By, img.phase, img.data, etc
```

---

1. Chess, J. J. et al. Streamlined approach to mapping the magnetic induction of skyrmionic materials. Ultramicroscopy 177, 78–83 (2017).

&#34;&#34;&#34;

# %%
import numpy as np
import os

from . import process
from . import constants as _
np.seterr(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;)

__all__ = [
                &#39;SITIEImage&#39;,
                &#39;ind_from_phase&#39;,
                &#39;sitie&#39;]

class SITIEImage:
        &#34;&#34;&#34;A SITIEImage object represents a defocussed image containing only magnetic contrast.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units. &lt;br /&gt;
                Allowed values are `&#34;pm&#34;`, `&#34;nm&#34;`, `&#34;µm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, and `&#34;m&#34;`.&lt;/li&gt;
                &lt;/ul&gt;
        &#34;&#34;&#34;
        def __init__(self, datafile):
                self.data = process.ndap(datafile.get(&#39;data&#39;))
                self.dx = datafile.get(&#39;pixelSize&#39;)[0]
                self.dy = datafile.get(&#39;pixelSize&#39;)[1]
                self.x_unit = datafile.get(&#39;pixelUnit&#39;)[0]
                self.y_unit = datafile.get(&#39;pixelUnit&#39;)[1]
                self.x = np.arange(0,self.data.shape[1]) * self.dx
                self.y = np.arange(0,self.data.shape[0]) * self.dy
                self.phase = None
                self.Bx, self.By = None, None
                self.fix_units()

        def fix_units(self):
                &#34;&#34;&#34;Set the units to meters.&#34;&#34;&#34;
                if self.x_unit == &#39;m&#39;:
                        xr = 1
                elif self.x_unit == &#39;mm&#39;:
                        xr = 1e-3
                elif self.x_unit == &#39;µm&#39; or self.x_unit == &#39;um&#39;:
                        xr = 1e-6
                elif self.x_unit == &#39;nm&#39;:
                        xr = 1e-9
                elif self.x_unit == &#39;pm&#39;:
                        xr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                if self.y_unit == &#39;m&#39;:
                        yr = 1
                elif self.y_unit == &#39;mm&#39;:
                        yr = 1e-3
                elif self.y_unit == &#39;µm&#39; or self.y_unit == &#39;um&#39;:
                        yr = 1e-6
                elif self.y_unit == &#39;nm&#39;:
                        yr = 1e-9
                elif self.y_unit == &#39;pm&#39;:
                        yr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))

        def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
                &#34;&#34;&#34;Change the pixel units.

                **Parameters**

                * **xr** : _number, optional_ &lt;br /&gt;
                New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
                Default is `xr = 1`.

                * **x_unit** : _string, optional_ &lt;br /&gt;
                The new x-units (e.g., &#34;nm&#34; or &#34;µm&#34;). &lt;br /&gt;
                Default is `x_unit = &#34;&#34;`.

                * **yr** : _number, optional_ &lt;br /&gt;
                New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
                If left empty, defaults to `xr`&lt;br /&gt;
                Default is `yr = None`.

                * **y_unit** : _string, optional_ &lt;br /&gt;
                The new y-units (e.g., &#34;nm&#34; or &#34;µm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
                Default is `y_unit = None`.

                **Returns**

                * _SITIEImage_
                &#34;&#34;&#34;
                if yr is None:
                        yr = xr
                if y_unit is None:
                        y_unit = x_unit
                self.x_unit = x_unit
                self.y_unit = y_unit
                self.dx *= xr
                self.dy *= yr
                self.x *= xr
                self.y *= yr
                return(self)

        def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
                &#34;&#34;&#34;Carries out phase and B-field reconstruction.

                Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

                **Parameters**

                * **df** : _number, optional_ &lt;br /&gt;
                The defocus at which the images were taken. &lt;br /&gt;
                Default is `df = 1e-3`.

                * **thickness** : _number, optional_ &lt;br /&gt;
                The thickness of the sample. &lt;br /&gt;
                Default is `thickness = 60e-9`.

                * **wavelength** : _number, optional_ &lt;br /&gt;
                The electron wavelength. &lt;br /&gt;
                Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

                **Returns**

                * _SITIEImage_
                &#34;&#34;&#34;
                self.phase = process.ndap(sitie(self.data, df, self.dx, self.dy, wavelength))
                self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, dx = self.dx, dy = self.dy, thickness = thickness)]
                return(self)

        def validate(self, threshold = 0.1, divangle = 1e-5, defocus = 1):
                r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

                SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
                low divergence angle relative to the defocus and the spatial frequencies to be resolved).
                Another way to say this is that the damping envelope \(g(q_{\perp})\) is negligible.

                This returns \(q_{\perp}\) satisfying

                \[\frac{(\pi \Theta_c \Delta f)^2}{2} q_{\perp}^2 = \text{threshold}\]

                where \(\Delta f\) is the defocus and \(\Theta_c\) is the divergence angle. This \(q_{\perp}\)
                is the largest spatial frequency for which the SITIE approximation is valid.

                **Parameters**

                * **threshold** : _number, optional_ &lt;br /&gt;
                The largest value that you consider \(&lt;&lt; 1\). &lt;br /&gt;
                Default is `threshold = 0.1`.

                * **divangle** : _number, optional_ &lt;br /&gt;
                The divergence angle. &lt;br /&gt;
                Default is `divangle = 1e-5`.

                * **defocus** : _number, optional_ &lt;br /&gt;
                Default is `defocus = 1`.

                * ****kwargs** &lt;br /&gt;
                Any arguments to be passed to the damping function.
                &#34;&#34;&#34;
                prefactor = np.abs((_.pi * divangle * defocus)**2 / 2)
                qp_max = np.sqrt(threshold / prefactor)
                return(qp_max)

def sitie(img, defocus = 0, dx = 1, dy = 1, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the Aharonov-Bohm phase from a defocussed image.

        This is an implementation of the SITIE equation from [1], Eqn (10).

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed Aharonov-Bohm phase shift.
        &#34;&#34;&#34;
        Sx = np.fft.fftfreq(img.shape[1], dx)
        Sy = np.fft.fftfreq(img.shape[0], dy)
        sx, sy = np.meshgrid(Sx, Sy)
        rhs = np.nan_to_num(2 * _.pi / wavelength / defocus * (1 - img / np.mean(img)), posinf = 0, neginf = 0)
        rhs = process.shift_pos(rhs)
        rhs = np.fft.fft2(rhs) / -4 / _.pi**2 / (sx**2 + sy**2)
        rhs = np.nan_to_num(rhs, posinf = 0, neginf = 0)
        phase = np.fft.ifft2(rhs)
        return(phase.real)

def ind_from_phase(phase, dx = 1, dy = 1, thickness = 60e-9):
        r&#34;&#34;&#34;Calculate the magnetic induction given the Aharonov-Bohm phase shift.

        Calculated using

        \[\nabla_{\perp} \phi_m = -\frac{e\tau}{\hbar} \left[\mathbf{B}\times\hat{\mathbf{e}}_{z}\right]\]

        where \(\tau\) is the thickness, \(\mathbf{B}\) is the transverse magnetic field components, integrated over \(z\),
        and \(\hat{\mathbf{e}}_z\) is the direction of propagation.

        **Parameters**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the electron phase immediately after the sample.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        The x-component of the magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        The y-component of the magnetic induction.
        &#34;&#34;&#34;
        dpdx = np.gradient(phase, dy, axis=1)
        dpdy = np.gradient(phase, dx, axis=0)
        Bx = _.hbar/_.e/thickness * dpdy
        By = -_.hbar/_.e/thickness * dpdx
        return(np.array([Bx.real, By.real]))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ltempy.sitie.ind_from_phase"><code class="name flex">
<span>def <span class="ident">ind_from_phase</span></span>(<span>phase, dx=1, dy=1, thickness=6e-08)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the magnetic induction given the Aharonov-Bohm phase shift.</p>
<p>Calculated using</p>
<p><span><span class="MathJax_Preview">\nabla_{\perp} \phi_m = -\frac{e\tau}{\hbar} \left[\mathbf{B}\times\hat{\mathbf{e}}_{z}\right]</span><script type="math/tex; mode=display">\nabla_{\perp} \phi_m = -\frac{e\tau}{\hbar} \left[\mathbf{B}\times\hat{\mathbf{e}}_{z}\right]</script></span></p>
<p>where <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span> is the thickness, <span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> is the transverse magnetic field components, integrated over <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>,
and <span><span class="MathJax_Preview">\hat{\mathbf{e}}_z</span><script type="math/tex">\hat{\mathbf{e}}_z</script></span> is the direction of propagation.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>phase</strong> : <em>ndarray</em> <br />
A 2d array containing the electron phase immediately after the sample.</p>
</li>
<li>
<p><strong>dx</strong> : <em>number, optional</em> <br />
The pixel spacing in the x-direction. <br />
Default is <code>dx = 1</code></p>
</li>
<li>
<p><strong>dy</strong> : <em>number, optional</em> <br />
The pixel spacing in the y-direction. <br />
Default is <code>dy = 1</code>.</p>
</li>
<li>
<p><strong>thickness</strong> : <em>number, optional</em> <br />
The thickness of the sample. <br />
Default is <code>thickness = 60e-9</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li>
<p><strong>Bx</strong> : <em>ndarray</em> <br />
The x-component of the magnetic induction.</p>
</li>
<li>
<p><strong>By</strong> : <em>ndarray</em> <br />
The y-component of the magnetic induction.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind_from_phase(phase, dx = 1, dy = 1, thickness = 60e-9):
        r&#34;&#34;&#34;Calculate the magnetic induction given the Aharonov-Bohm phase shift.

        Calculated using

        \[\nabla_{\perp} \phi_m = -\frac{e\tau}{\hbar} \left[\mathbf{B}\times\hat{\mathbf{e}}_{z}\right]\]

        where \(\tau\) is the thickness, \(\mathbf{B}\) is the transverse magnetic field components, integrated over \(z\),
        and \(\hat{\mathbf{e}}_z\) is the direction of propagation.

        **Parameters**

        * **phase** : _ndarray_ &lt;br /&gt;
        A 2d array containing the electron phase immediately after the sample.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        **Returns**

        * **Bx** : _ndarray_ &lt;br /&gt;
        The x-component of the magnetic induction.

        * **By** : _ndarray_ &lt;br /&gt;
        The y-component of the magnetic induction.
        &#34;&#34;&#34;
        dpdx = np.gradient(phase, dy, axis=1)
        dpdy = np.gradient(phase, dx, axis=0)
        Bx = _.hbar/_.e/thickness * dpdy
        By = -_.hbar/_.e/thickness * dpdx
        return(np.array([Bx.real, By.real]))</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.sitie"><code class="name flex">
<span>def <span class="ident">sitie</span></span>(<span>img, defocus=0, dx=1, dy=1, wavelength=1.97e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct the Aharonov-Bohm phase from a defocussed image.</p>
<p>This is an implementation of the SITIE equation from [1], Eqn (10).</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>img</strong> : <em>ndarray</em> <br />
The 2d image data.</p>
</li>
<li>
<p><strong>defocus</strong> : <em>number, optional</em> <br />
Default is <code>defocus = 0</code>.</p>
</li>
<li>
<p><strong>dx</strong> : <em>number, optional</em> <br />
The pixel spacing in the x-direction. <br />
Default is <code>dx = 1</code></p>
</li>
<li>
<p><strong>dy</strong> : <em>number, optional</em> <br />
The pixel spacing in the y-direction. <br />
Default is <code>dy = 1</code>.</p>
</li>
<li>
<p><strong>wavelength</strong> : <em>number, optional</em> <br />
The relativistic electron wavelength. <br />
Default is <code>wavelength = 1.97e-9</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>ndarray</em> <br />
A 2d array containing the reconstructed Aharonov-Bohm phase shift.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sitie(img, defocus = 0, dx = 1, dy = 1, wavelength = 1.97e-12):
        &#34;&#34;&#34;Reconstruct the Aharonov-Bohm phase from a defocussed image.

        This is an implementation of the SITIE equation from [1], Eqn (10).

        **Parameters**

        * **img** : _ndarray_ &lt;br /&gt;
        The 2d image data.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 0`.

        * **dx** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the x-direction. &lt;br /&gt;
        Default is `dx = 1`

        * **dy** : _number, optional_ &lt;br /&gt;
        The pixel spacing in the y-direction. &lt;br /&gt;
        Default is `dy = 1`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The relativistic electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.97e-9`.

        **Returns**

        * _ndarray_ &lt;br /&gt;
        A 2d array containing the reconstructed Aharonov-Bohm phase shift.
        &#34;&#34;&#34;
        Sx = np.fft.fftfreq(img.shape[1], dx)
        Sy = np.fft.fftfreq(img.shape[0], dy)
        sx, sy = np.meshgrid(Sx, Sy)
        rhs = np.nan_to_num(2 * _.pi / wavelength / defocus * (1 - img / np.mean(img)), posinf = 0, neginf = 0)
        rhs = process.shift_pos(rhs)
        rhs = np.fft.fft2(rhs) / -4 / _.pi**2 / (sx**2 + sy**2)
        rhs = np.nan_to_num(rhs, posinf = 0, neginf = 0)
        phase = np.fft.ifft2(rhs)
        return(phase.real)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ltempy.sitie.SITIEImage"><code class="flex name class">
<span>class <span class="ident">SITIEImage</span></span>
<span>(</span><span>datafile)</span>
</code></dt>
<dd>
<div class="desc"><p>A SITIEImage object represents a defocussed image containing only magnetic contrast.</p>
<p><strong>Parameters</strong></p>
<ul>
<li><strong>datafile</strong> : <em>dictionary</em> <br />
a dictionary with the following keys: <br />
<ul>
<li> <strong>data</strong> : <em>ndarray</em> <br />
A 2d array of the electron counts. </li>
<li> <strong>pixelSize</strong> : <em>tuple</em> <br />
(<em>number</em>, <em>number</em>) - the x and y pixel sizes. </li>
<li> <strong>pixelUnit</strong> : <em>tuple</em> <br />
(<em>string</em>, <em>string</em>) - the x and y pixel units. <br />
Allowed values are <code>"pm"</code>, <code>"nm"</code>, <code>"µm"</code>, <code>"um"</code>, <code>"mm"</code>, and <code>"m"</code>.</li>
</ul></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SITIEImage:
        &#34;&#34;&#34;A SITIEImage object represents a defocussed image containing only magnetic contrast.

        **Parameters**

        * **datafile** : _dictionary_ &lt;br /&gt;
        a dictionary with the following keys: &lt;br /&gt;
                &lt;ul&gt;
                &lt;li&gt; **data** : _ndarray_ &lt;br /&gt;
                A 2d array of the electron counts. &lt;/li&gt;
                &lt;li&gt; **pixelSize** : _tuple_ &lt;br /&gt;
                (_number_, _number_) - the x and y pixel sizes. &lt;/li&gt;
                &lt;li&gt; **pixelUnit** : _tuple_ &lt;br /&gt;
                (_string_, _string_) - the x and y pixel units. &lt;br /&gt;
                Allowed values are `&#34;pm&#34;`, `&#34;nm&#34;`, `&#34;µm&#34;`, `&#34;um&#34;`, `&#34;mm&#34;`, and `&#34;m&#34;`.&lt;/li&gt;
                &lt;/ul&gt;
        &#34;&#34;&#34;
        def __init__(self, datafile):
                self.data = process.ndap(datafile.get(&#39;data&#39;))
                self.dx = datafile.get(&#39;pixelSize&#39;)[0]
                self.dy = datafile.get(&#39;pixelSize&#39;)[1]
                self.x_unit = datafile.get(&#39;pixelUnit&#39;)[0]
                self.y_unit = datafile.get(&#39;pixelUnit&#39;)[1]
                self.x = np.arange(0,self.data.shape[1]) * self.dx
                self.y = np.arange(0,self.data.shape[0]) * self.dy
                self.phase = None
                self.Bx, self.By = None, None
                self.fix_units()

        def fix_units(self):
                &#34;&#34;&#34;Set the units to meters.&#34;&#34;&#34;
                if self.x_unit == &#39;m&#39;:
                        xr = 1
                elif self.x_unit == &#39;mm&#39;:
                        xr = 1e-3
                elif self.x_unit == &#39;µm&#39; or self.x_unit == &#39;um&#39;:
                        xr = 1e-6
                elif self.x_unit == &#39;nm&#39;:
                        xr = 1e-9
                elif self.x_unit == &#39;pm&#39;:
                        xr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                if self.y_unit == &#39;m&#39;:
                        yr = 1
                elif self.y_unit == &#39;mm&#39;:
                        yr = 1e-3
                elif self.y_unit == &#39;µm&#39; or self.y_unit == &#39;um&#39;:
                        yr = 1e-6
                elif self.y_unit == &#39;nm&#39;:
                        yr = 1e-9
                elif self.y_unit == &#39;pm&#39;:
                        yr = 1e-12
                else:
                        print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                        return(self)
                return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))

        def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
                &#34;&#34;&#34;Change the pixel units.

                **Parameters**

                * **xr** : _number, optional_ &lt;br /&gt;
                New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
                Default is `xr = 1`.

                * **x_unit** : _string, optional_ &lt;br /&gt;
                The new x-units (e.g., &#34;nm&#34; or &#34;µm&#34;). &lt;br /&gt;
                Default is `x_unit = &#34;&#34;`.

                * **yr** : _number, optional_ &lt;br /&gt;
                New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
                If left empty, defaults to `xr`&lt;br /&gt;
                Default is `yr = None`.

                * **y_unit** : _string, optional_ &lt;br /&gt;
                The new y-units (e.g., &#34;nm&#34; or &#34;µm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
                Default is `y_unit = None`.

                **Returns**

                * _SITIEImage_
                &#34;&#34;&#34;
                if yr is None:
                        yr = xr
                if y_unit is None:
                        y_unit = x_unit
                self.x_unit = x_unit
                self.y_unit = y_unit
                self.dx *= xr
                self.dy *= yr
                self.x *= xr
                self.y *= yr
                return(self)

        def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
                &#34;&#34;&#34;Carries out phase and B-field reconstruction.

                Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

                **Parameters**

                * **df** : _number, optional_ &lt;br /&gt;
                The defocus at which the images were taken. &lt;br /&gt;
                Default is `df = 1e-3`.

                * **thickness** : _number, optional_ &lt;br /&gt;
                The thickness of the sample. &lt;br /&gt;
                Default is `thickness = 60e-9`.

                * **wavelength** : _number, optional_ &lt;br /&gt;
                The electron wavelength. &lt;br /&gt;
                Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

                **Returns**

                * _SITIEImage_
                &#34;&#34;&#34;
                self.phase = process.ndap(sitie(self.data, df, self.dx, self.dy, wavelength))
                self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, dx = self.dx, dy = self.dy, thickness = thickness)]
                return(self)

        def validate(self, threshold = 0.1, divangle = 1e-5, defocus = 1):
                r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

                SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
                low divergence angle relative to the defocus and the spatial frequencies to be resolved).
                Another way to say this is that the damping envelope \(g(q_{\perp})\) is negligible.

                This returns \(q_{\perp}\) satisfying

                \[\frac{(\pi \Theta_c \Delta f)^2}{2} q_{\perp}^2 = \text{threshold}\]

                where \(\Delta f\) is the defocus and \(\Theta_c\) is the divergence angle. This \(q_{\perp}\)
                is the largest spatial frequency for which the SITIE approximation is valid.

                **Parameters**

                * **threshold** : _number, optional_ &lt;br /&gt;
                The largest value that you consider \(&lt;&lt; 1\). &lt;br /&gt;
                Default is `threshold = 0.1`.

                * **divangle** : _number, optional_ &lt;br /&gt;
                The divergence angle. &lt;br /&gt;
                Default is `divangle = 1e-5`.

                * **defocus** : _number, optional_ &lt;br /&gt;
                Default is `defocus = 1`.

                * ****kwargs** &lt;br /&gt;
                Any arguments to be passed to the damping function.
                &#34;&#34;&#34;
                prefactor = np.abs((_.pi * divangle * defocus)**2 / 2)
                qp_max = np.sqrt(threshold / prefactor)
                return(qp_max)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ltempy.sitie.SITIEImage.fix_units"><code class="name flex">
<span>def <span class="ident">fix_units</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the units to meters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_units(self):
        &#34;&#34;&#34;Set the units to meters.&#34;&#34;&#34;
        if self.x_unit == &#39;m&#39;:
                xr = 1
        elif self.x_unit == &#39;mm&#39;:
                xr = 1e-3
        elif self.x_unit == &#39;µm&#39; or self.x_unit == &#39;um&#39;:
                xr = 1e-6
        elif self.x_unit == &#39;nm&#39;:
                xr = 1e-9
        elif self.x_unit == &#39;pm&#39;:
                xr = 1e-12
        else:
                print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                return(self)
        if self.y_unit == &#39;m&#39;:
                yr = 1
        elif self.y_unit == &#39;mm&#39;:
                yr = 1e-3
        elif self.y_unit == &#39;µm&#39; or self.y_unit == &#39;um&#39;:
                yr = 1e-6
        elif self.y_unit == &#39;nm&#39;:
                yr = 1e-9
        elif self.y_unit == &#39;pm&#39;:
                yr = 1e-12
        else:
                print(&#34;Failed to set units to meters - pixelUnit was not recognized.&#34;)
                return(self)
        return(self.set_units(xr, &#34;m&#34;, yr, &#34;m&#34;))</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self, df=0.001, thickness=6e-08, wavelength=1.97e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out phase and B-field reconstruction.</p>
<p>Assigns <code>self.phase</code>, <code>self.Bx</code>, and <code>self.By</code> attributes.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>df</strong> : <em>number, optional</em> <br />
The defocus at which the images were taken. <br />
Default is <code>df = 1e-3</code>.</p>
</li>
<li>
<p><strong>thickness</strong> : <em>number, optional</em> <br />
The thickness of the sample. <br />
Default is <code>thickness = 60e-9</code>.</p>
</li>
<li>
<p><strong>wavelength</strong> : <em>number, optional</em> <br />
The electron wavelength. <br />
Default is <code>wavelength = 1.96e-12</code> (relativistic wavelength of a 300kV electron).</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>SITIEImage</em></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct(self, df = 1e-3, thickness = 60e-9, wavelength=1.97e-12):
        &#34;&#34;&#34;Carries out phase and B-field reconstruction.

        Assigns `self.phase`, `self.Bx`, and `self.By` attributes.

        **Parameters**

        * **df** : _number, optional_ &lt;br /&gt;
        The defocus at which the images were taken. &lt;br /&gt;
        Default is `df = 1e-3`.

        * **thickness** : _number, optional_ &lt;br /&gt;
        The thickness of the sample. &lt;br /&gt;
        Default is `thickness = 60e-9`.

        * **wavelength** : _number, optional_ &lt;br /&gt;
        The electron wavelength. &lt;br /&gt;
        Default is `wavelength = 1.96e-12` (relativistic wavelength of a 300kV electron).

        **Returns**

        * _SITIEImage_
        &#34;&#34;&#34;
        self.phase = process.ndap(sitie(self.data, df, self.dx, self.dy, wavelength))
        self.Bx, self.By = [process.ndap(arr) for arr in ind_from_phase(self.phase, dx = self.dx, dy = self.dy, thickness = thickness)]
        return(self)</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.set_units"><code class="name flex">
<span>def <span class="ident">set_units</span></span>(<span>self, xr=1, x_unit='', yr=None, y_unit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the pixel units.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>xr</strong> : <em>number, optional</em> <br />
New x-units per old x-units. (For example, 1e3 to convert from meters to mm). <br />
Default is <code>xr = 1</code>.</p>
</li>
<li>
<p><strong>x_unit</strong> : <em>string, optional</em> <br />
The new x-units (e.g., "nm" or "µm"). <br />
Default is <code>x_unit = ""</code>.</p>
</li>
<li>
<p><strong>yr</strong> : <em>number, optional</em> <br />
New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
If left empty, defaults to <code>xr</code><br />
Default is <code>yr = None</code>.</p>
</li>
<li>
<p><strong>y_unit</strong> : <em>string, optional</em> <br />
The new y-units (e.g., "nm" or "µm"). If left empty, defaults to <code>x_unit</code>. <br />
Default is <code>y_unit = None</code>.</p>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>SITIEImage</em></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_units(self, xr=1, x_unit=&#34;&#34;, yr=None, y_unit=None):
        &#34;&#34;&#34;Change the pixel units.

        **Parameters**

        * **xr** : _number, optional_ &lt;br /&gt;
        New x-units per old x-units. (For example, 1e3 to convert from meters to mm). &lt;br /&gt;
        Default is `xr = 1`.

        * **x_unit** : _string, optional_ &lt;br /&gt;
        The new x-units (e.g., &#34;nm&#34; or &#34;µm&#34;). &lt;br /&gt;
        Default is `x_unit = &#34;&#34;`.

        * **yr** : _number, optional_ &lt;br /&gt;
        New y-units per old y-units. (For example, 1e3 to convert from meters to mm).
        If left empty, defaults to `xr`&lt;br /&gt;
        Default is `yr = None`.

        * **y_unit** : _string, optional_ &lt;br /&gt;
        The new y-units (e.g., &#34;nm&#34; or &#34;µm&#34;). If left empty, defaults to `x_unit`. &lt;br /&gt;
        Default is `y_unit = None`.

        **Returns**

        * _SITIEImage_
        &#34;&#34;&#34;
        if yr is None:
                yr = xr
        if y_unit is None:
                y_unit = x_unit
        self.x_unit = x_unit
        self.y_unit = y_unit
        self.dx *= xr
        self.dy *= yr
        self.x *= xr
        self.y *= yr
        return(self)</code></pre>
</details>
</dd>
<dt id="ltempy.sitie.SITIEImage.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, threshold=0.1, divangle=1e-05, defocus=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the validity of the SITIE approximation for the given parameters.</p>
<p>SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
low divergence angle relative to the defocus and the spatial frequencies to be resolved).
Another way to say this is that the damping envelope <span><span class="MathJax_Preview">g(q_{\perp})</span><script type="math/tex">g(q_{\perp})</script></span> is negligible.</p>
<p>This returns <span><span class="MathJax_Preview">q_{\perp}</span><script type="math/tex">q_{\perp}</script></span> satisfying</p>
<p><span><span class="MathJax_Preview">\frac{(\pi \Theta_c \Delta f)^2}{2} q_{\perp}^2 = \text{threshold}</span><script type="math/tex; mode=display">\frac{(\pi \Theta_c \Delta f)^2}{2} q_{\perp}^2 = \text{threshold}</script></span></p>
<p>where <span><span class="MathJax_Preview">\Delta f</span><script type="math/tex">\Delta f</script></span> is the defocus and <span><span class="MathJax_Preview">\Theta_c</span><script type="math/tex">\Theta_c</script></span> is the divergence angle. This <span><span class="MathJax_Preview">q_{\perp}</span><script type="math/tex">q_{\perp}</script></span>
is the largest spatial frequency for which the SITIE approximation is valid.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>
<p><strong>threshold</strong> : <em>number, optional</em> <br />
The largest value that you consider <span><span class="MathJax_Preview">&lt;&lt; 1</span><script type="math/tex"><< 1</script></span>. <br />
Default is <code>threshold = 0.1</code>.</p>
</li>
<li>
<p><strong>divangle</strong> : <em>number, optional</em> <br />
The divergence angle. <br />
Default is <code>divangle = 1e-5</code>.</p>
</li>
<li>
<p><strong>defocus</strong> : <em>number, optional</em> <br />
Default is <code>defocus = 1</code>.</p>
</li>
<li>
<p><strong>**kwargs</strong> <br />
Any arguments to be passed to the damping function.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, threshold = 0.1, divangle = 1e-5, defocus = 1):
        r&#34;&#34;&#34;Estimate the validity of the SITIE approximation for the given parameters.

        SITIE expands on the approximations of TIE by assuming coherent illumination (that is,
        low divergence angle relative to the defocus and the spatial frequencies to be resolved).
        Another way to say this is that the damping envelope \(g(q_{\perp})\) is negligible.

        This returns \(q_{\perp}\) satisfying

        \[\frac{(\pi \Theta_c \Delta f)^2}{2} q_{\perp}^2 = \text{threshold}\]

        where \(\Delta f\) is the defocus and \(\Theta_c\) is the divergence angle. This \(q_{\perp}\)
        is the largest spatial frequency for which the SITIE approximation is valid.

        **Parameters**

        * **threshold** : _number, optional_ &lt;br /&gt;
        The largest value that you consider \(&lt;&lt; 1\). &lt;br /&gt;
        Default is `threshold = 0.1`.

        * **divangle** : _number, optional_ &lt;br /&gt;
        The divergence angle. &lt;br /&gt;
        Default is `divangle = 1e-5`.

        * **defocus** : _number, optional_ &lt;br /&gt;
        Default is `defocus = 1`.

        * ****kwargs** &lt;br /&gt;
        Any arguments to be passed to the damping function.
        &#34;&#34;&#34;
        prefactor = np.abs((_.pi * divangle * defocus)**2 / 2)
        qp_max = np.sqrt(threshold / prefactor)
        return(qp_max)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ltempy" href="index.html">ltempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ltempy.sitie.ind_from_phase" href="#ltempy.sitie.ind_from_phase">ind_from_phase</a></code></li>
<li><code><a title="ltempy.sitie.sitie" href="#ltempy.sitie.sitie">sitie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ltempy.sitie.SITIEImage" href="#ltempy.sitie.SITIEImage">SITIEImage</a></code></h4>
<ul class="">
<li><code><a title="ltempy.sitie.SITIEImage.fix_units" href="#ltempy.sitie.SITIEImage.fix_units">fix_units</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.reconstruct" href="#ltempy.sitie.SITIEImage.reconstruct">reconstruct</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.set_units" href="#ltempy.sitie.SITIEImage.set_units">set_units</a></code></li>
<li><code><a title="ltempy.sitie.SITIEImage.validate" href="#ltempy.sitie.SITIEImage.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>